#include <msp430.h> 

/**
 * 练习203 单击按键控制LED
 *
 * MSP-EXP430F5529LP：
 * 两个用户按键:P2.1->S1;P1.1->S2
 * 两个用户LED:P1.0->LED1;P4.7->LED2
 *
 * S2控制LED1；
 *
 * 按键消抖
 * 按键释放
 *
 * 基本功能： 按键S2,控制LED1;
 * 思考与扩展： 按键S1,控制LED2;
 */
void main(void)
{
    //停用看门狗
	WDTCTL = WDTPW | WDTHOLD;

	//设置P1.1为输入
	//P1DIR = P1DIR & ~BIT1;
    //P1DIR & ~BIT1 -->屏蔽无关位,指定位清零  p1有8个引脚，即8个比特位，
    //   P1. 7654 3210
    // P1DIR xxxx xxxx
    // BIT1  0000 0010
	//~BIT1  1111 1101
    //   &   xxxx xx0x   --》只是把特定的比特位清零
    P1DIR &= ~BIT1;

    //启用P1.1的内部上下拉电阻,且设置为上拉
    //P1REN = P1REN | BIT1;
    //P1REN | BIT1 -->屏蔽无关位,指定位置1； p1有8个引脚，即8个比特位，
    //   P1. 7654 3210
    // P1REN xxxx xxxx
    // BIT1  0000 0010
    //   |   xxxx xx1x   --》只是把特定的比特位置1
    P1REN |= BIT1;
    P1OUT |= BIT1;

    //设置P1.0为输出，控制红色LED
    P1DIR |= BIT0;
    //初始化灯的状态，熄灭
    P1OUT &= ~BIT0;

    while(1)
    {
        //读取引脚P1.1,如果是低电平,则点亮LED
        // P1IN & BIT1 -->屏蔽无关位,  p1有8个引脚，即8个比特位，
        //   P1. 7654 3210
        // P1IN  xxxx xxxx
        // BIT1  0000 0010
        //   &   0000 00x0  --》只保留P1.1的输入值
        //此时，
        //P1.1为高电平(按键未动), 0000 0010 = BIT1
        //P1.1为低电平(按键按下), 0000 0000 = 0x00
        if((P1IN&BIT1)==0x00)
        {
            //延长周期数nop()
            //每个周期是多长时间呢? 默认的时频率~1MHz
            __delay_cycles(20000);  //20ms延时
            if((P1IN&BIT1)==0x00)
            {
                //取反操作; 原来是1的,取反后为0;原来是0的，取反后为1；
                //对应到LED，原来亮的，变灭； 原来灭的，变亮;
                P1OUT ^= BIT0;
                //等待按键释放
                while((P1IN&BIT1)==0x00);
            }
        }

    }
}
